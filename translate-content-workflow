{
  "userInputs": [
    {
      "id": "content-url-input",
      "type": "input",
      "name": "Original Content URL",
      "description": "Enter the URL of the original content to translate (e.g., https://dev-www.frevana.com/content/article-title-content-id)",
      "placeholder": "https://dev-www.frevana.com/content/...",
      "required": true
    },
    {
      "id": "target-language-input",
      "type": "input",
      "name": "Target Language",
      "description": "Enter the target language code (e.g., zh, es, fr, ja)",
      "placeholder": "zh",
      "required": true
    }
  ],
  "workflows": [
    {
      "id": "extract-content-id",
      "nameV2": "Extract Content ID",
      "type": "script",
      "outputFormat": "text",
      "script": "module.exports = async function() {\n  // Extract content ID from URL\n  const url = data['content-url-input'] || '';\n  \n  if (!url) {\n    throw new Error('Content URL is required');\n  }\n  \n  // Extract content ID from URL pattern: https://domain.com/content/article-title-content-id\n  // The content ID is the last segment after the last dash\n  const urlParts = url.split('/');\n  const lastPart = urlParts[urlParts.length - 1];\n  \n  // Extract content ID (usually the last segment after the last dash)\n  const segments = lastPart.split('-');\n  const contentId = segments[segments.length - 1];\n  \n  if (!contentId || contentId.length < 10) {\n    throw new Error(`Invalid content ID extracted from URL: ${contentId}`);\n  }\n  \n  console.log(`Extracted content ID: ${contentId}`);\n  return contentId;\n};",
      "nodeIds": ["content-url-input"]
    },
    {
      "id": "check-existing-translation",
      "nameV2": "Check Existing Translation",
      "type": "script",
      "outputFormat": "text",
      "script": "module.exports = async function() {\n  const contentId = data['extract-content-id'] || '';\n  const targetLanguage = data['target-language-input'] || 'zh';\n  \n  if (!contentId) {\n    throw new Error('Content ID is required');\n  }\n  \n  console.log(`Checking existing translations for content ID: ${contentId}`);\n  \n  // Check if translation already exists\n  const versionsResponse = await api.frevanaApi.request(\n    'GET',\n    `/s3/content/${contentId}/language-versions`\n  );\n  \n  if (versionsResponse.ok && versionsResponse.data && versionsResponse.data.versions) {\n    const existingTranslation = versionsResponse.data.versions.find(\n      (v) => v.language_code === targetLanguage\n    );\n    \n    if (existingTranslation) {\n      console.log(`Translation for language '${targetLanguage}' already exists: ${existingTranslation.content_id}`);\n      return JSON.stringify({\n        exists: true,\n        contentId: existingTranslation.content_id,\n        url: existingTranslation.url,\n        targetLanguage: targetLanguage,\n        contentGroupId: versionsResponse.data.content_group_id\n      });\n    }\n  }\n  \n  console.log(`No existing translation found for language '${targetLanguage}', proceeding with new translation`);\n  return JSON.stringify({\n    exists: false,\n    contentId: contentId,\n    targetLanguage: targetLanguage\n  });\n};",
      "nodeIds": ["extract-content-id", "target-language-input"]
    },
    {
      "id": "prepare-translation",
      "nameV2": "Prepare Translation",
      "type": "script",
      "outputFormat": "text",
      "script": "module.exports = async function() {\n  const checkResult = JSON.parse(data['check-existing-translation'] || '{}');\n  \n  // If translation already exists, skip preparation\n  if (checkResult.exists) {\n    console.log('Translation already exists, skipping preparation');\n    return JSON.stringify({\n      skipTranslation: true,\n      existingContentId: checkResult.contentId,\n      existingUrl: checkResult.url,\n      targetLanguage: checkResult.targetLanguage,\n      contentGroupId: checkResult.contentGroupId\n    });\n  }\n  \n  const contentId = checkResult.contentId || '';\n  const targetLanguage = checkResult.targetLanguage || 'zh';\n  \n  console.log(`Preparing new translation for content ID: ${contentId}, target language: ${targetLanguage}`);\n  \n  // Call prepare-translate API\n  const response = await api.frevanaApi.request(\n    'POST',\n    `/s3/content/${contentId}/prepare-translate`,\n    {\n      target_language: targetLanguage\n    }\n  );\n  \n  if (!response.ok) {\n    throw new Error(`Failed to prepare translation: ${JSON.stringify(response.data)}`);\n  }\n  \n  const result = response.data;\n  console.log(`Translation prepared successfully. New content ID: ${result.new_content_id}`);\n  \n  // Return JSON string with all necessary data\n  return JSON.stringify({\n    skipTranslation: false,\n    contentId: contentId,\n    newContentId: result.new_content_id,\n    contentGroupId: result.content_group_id,\n    downloadUrl: result.download_url,\n    uploadUrl: result.upload_url,\n    targetLanguage: targetLanguage,\n    originalLanguage: result.original_language,\n    expiresAt: result.expires_at\n  });\n};",
      "nodeIds": ["check-existing-translation"]
    },
    {
      "id": "download-original-content",
      "nameV2": "Download Original Content",
      "type": "script",
      "outputFormat": "text",
      "script": "module.exports = async function() {\n  const prepareResult = JSON.parse(data['prepare-translation'] || '{}');\n  \n  // If translation already exists, get the existing translated content\n  if (prepareResult.skipTranslation && prepareResult.existingContentId) {\n    console.log(`Getting existing translated content for content ID: ${prepareResult.existingContentId}`);\n    \n    // Get language versions for the existing translated content\n    const versionsResponse = await api.frevanaApi.request(\n      'GET',\n      `/s3/content/${prepareResult.existingContentId}/language-versions`\n    );\n    \n    if (!versionsResponse.ok) {\n      console.error(`API call failed: status ${versionsResponse.status}, data: ${JSON.stringify(versionsResponse.data)}`);\n      throw new Error(`Failed to get existing translated content: HTTP ${versionsResponse.status} - ${JSON.stringify(versionsResponse.data)}`);\n    }\n    \n    if (!versionsResponse.data || !versionsResponse.data.versions) {\n      throw new Error('API response data is empty or invalid');\n    }\n    \n    // Find the version matching the target language\n    const targetLanguage = prepareResult.targetLanguage || 'zh';\n    const existingVersion = versionsResponse.data.versions.find(\n      (v) => v.language_code === targetLanguage\n    );\n    \n    if (!existingVersion || !existingVersion.download_url) {\n      throw new Error(`No download URL found for language '${targetLanguage}'`);\n    }\n    \n    console.log(`Downloading existing translation from S3...`);\n    \n    // Download HTML content from S3 presigned URL\n    const downloadResponse = await api.fetch(existingVersion.download_url);\n    const existingHtml = await downloadResponse.text();\n    \n    if (!existingHtml || existingHtml.length === 0) {\n      throw new Error('Downloaded content is empty');\n    }\n    \n    console.log(`Downloaded existing translation: ${existingHtml.length} characters`);\n    \n    return JSON.stringify({\n      ...prepareResult,\n      translatedHtml: existingHtml,\n      isExisting: true\n    });\n  }\n  \n  // Otherwise, download original content for new translation\n  const downloadUrl = prepareResult.downloadUrl;\n  \n  if (!downloadUrl) {\n    throw new Error('Download URL not found in prepare result');\n  }\n  \n  console.log('Downloading original content from S3...');\n  \n  // Download HTML content from S3 presigned URL\n  const response = await api.fetch(downloadUrl);\n  const htmlContent = await response.text();\n  \n  if (!htmlContent || htmlContent.length === 0) {\n    throw new Error('Downloaded content is empty');\n  }\n  \n  console.log(`Downloaded ${htmlContent.length} characters of HTML content`);\n  \n  // Return JSON with HTML content and metadata\n  return JSON.stringify({\n    ...prepareResult,\n    originalHtml: htmlContent,\n    isExisting: false\n  });\n};",
      "nodeIds": ["prepare-translation"]
    },
    {
      "id": "translate-content",
      "nameV2": "Translate Content",
      "type": "script",
      "outputFormat": "text",
      "script": "module.exports = async function() {\n  const downloadResult = JSON.parse(data['download-original-content'] || '{}');\n  \n  // If translation already exists, return it directly\n  if (downloadResult.isExisting && downloadResult.translatedHtml) {\n    console.log('Using existing translation, skipping AI translation');\n    return downloadResult.translatedHtml;\n  }\n  \n  // Otherwise, use AI to translate (this will be handled by translate-content-ai node)\n  const aiResult = await api.executeNode('translate-content-ai');\n  return aiResult || '';\n};",
      "nodeIds": ["download-original-content"]
    },
    {
      "id": "translate-content-ai",
      "nameV2": "AI Translation",
      "type": "ai_prompt",
      "outputFormat": "text",
      "prompt": "You are a professional translator. Translate the following HTML content.\n\nIMPORTANT:\n1. Preserve all HTML tags, attributes, and structure exactly as they are\n2. Only translate text content within HTML tags, not the tags themselves\n3. Preserve all URLs, links, and image sources unchanged\n4. Maintain the same formatting and structure\n5. Translate all visible text content accurately\n6. Translate the content inside <title> tags as well\n7. Translate all text content including headings, paragraphs, lists, and any other text elements\n\nFirst, extract the HTML content from this JSON data (look for the 'originalHtml' field):\n@[Step-4 Download Original Content](download-original-content)\n\nThen translate the HTML content from the original language to the target language specified in the JSON. Make sure to translate:\n- The <title> tag content\n- All headings (<h1>, <h2>, <h3>, etc.)\n- All paragraph text\n- All list items\n- All other visible text content\n\nReturn ONLY the translated HTML content, without any JSON wrapper, explanations, or additional text.",
      "model": "gpt-5.1",
      "nodeIds": ["download-original-content"]
    },
    {
      "id": "upload-translated-content",
      "nameV2": "Upload Translated Content",
      "type": "script",
      "outputFormat": "text",
      "script": "module.exports = async function() {\n  const downloadResult = JSON.parse(data['download-original-content'] || '{}');\n  const translatedHtml = data['translate-content'] || '';\n  \n  // If using existing translation, skip upload\n  if (downloadResult.isExisting) {\n    console.log('Using existing translation, skipping upload');\n    return JSON.stringify({\n      ...downloadResult,\n      translatedHtml: translatedHtml,\n      uploadStatus: 'skipped',\n      skipUpload: true\n    });\n  }\n  \n  const uploadUrl = downloadResult.uploadUrl;\n  \n  if (!uploadUrl) {\n    throw new Error('Upload URL not found');\n  }\n  \n  if (!translatedHtml) {\n    throw new Error('Translated HTML content is empty');\n  }\n  \n  console.log('Uploading translated content to S3...');\n  \n  // Upload translated HTML to S3 using presigned URL\n  const uploadResponse = await api.fetch(uploadUrl, {\n    method: 'PUT',\n    headers: {\n      'Content-Type': 'text/html'\n    },\n    body: translatedHtml\n  });\n  \n  if (uploadResponse.status !== 200 && uploadResponse.status !== 204) {\n    throw new Error(`Failed to upload translated content: HTTP ${uploadResponse.status}`);\n  }\n  \n  console.log('Translated content uploaded successfully');\n  \n  // Return JSON with upload confirmation\n  return JSON.stringify({\n    ...downloadResult,\n    translatedHtml: translatedHtml,\n    uploadStatus: 'success',\n    skipUpload: false\n  });\n};",
      "nodeIds": ["download-original-content", "translate-content"]
    },
    {
      "id": "confirm-translation",
      "nameV2": "Confirm Translation",
      "type": "script",
      "outputFormat": "text",
      "script": "module.exports = async function() {\n  const uploadResult = JSON.parse(data['upload-translated-content'] || '{}');\n  const translatedHtml = uploadResult.translatedHtml || '';\n  \n  if (!translatedHtml) {\n    throw new Error('Translated HTML content is empty');\n  }\n  \n  // If using existing translation, skip confirmation and return HTML directly\n  if (uploadResult.skipUpload) {\n    console.log('Using existing translation, skipping confirmation');\n    return translatedHtml;\n  }\n  \n  const newContentId = uploadResult.newContentId;\n  \n  if (!newContentId) {\n    throw new Error('New content ID not found');\n  }\n  \n  console.log(`Confirming translation for new content ID: ${newContentId}`);\n  \n  // Extract translated title from HTML\n  let title = 'Translated Content';\n  try {\n    const titleMatch = translatedHtml.match(/<title[^>]*>([^<]+)<\\/title>/i);\n    if (titleMatch && titleMatch[1]) {\n      title = titleMatch[1].trim();\n    }\n  } catch (e) {\n    console.log('Could not extract title from HTML');\n  }\n  \n  // Call confirm-translate API\n  const response = await api.frevanaApi.request(\n    'POST',\n    '/s3/content/confirm-translate',\n    {\n      new_content_id: newContentId,\n      title: title\n    }\n  );\n  \n  if (!response.ok) {\n    throw new Error(`Failed to confirm translation: ${JSON.stringify(response.data)}`);\n  }\n  \n  const result = response.data;\n  console.log(`Translation confirmed successfully. Content URL: ${result.url}`);\n  \n  // Return translated HTML directly instead of JSON\n  return translatedHtml;\n};",
      "nodeIds": ["upload-translated-content"]
    }
  ],
  "results": [
    {
      "type": "html",
      "fields": ["content"],
      "items": { "content": "confirm-translation" }
    }
  ],
  "inputValues": {},
  "version": "1.0",
  "metadata": {
    "author": "System",
    "createdAt": "2025-01-15T00:00:00.000Z"
  },
  "frequency": "-1",
  "mcpConfigs": {},
  "workflowConnects": []
}
