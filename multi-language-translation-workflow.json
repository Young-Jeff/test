{
  "userInputs": [
    {
      "id": "content-url-input",
      "type": "input",
      "name": "Original Content URL",
      "description": "Enter the URL of the original content to translate (e.g., https://dev-www.frevana.com/content/article-title-content-id)",
      "placeholder": "https://dev-www.frevana.com/content/...",
      "required": true
    },
    {
      "id": "target-languages-input",
      "type": "keywords",
      "name": "Target Languages (comma-separated)",
      "description": "Enter language codes separated by commas (e.g., zh, ja, es, fr, de)",
      "placeholder": "zh, ja, es",
      "required": true
    }
  ],
  "workflows": [
    {
      "id": "extract-content-id",
      "nameV2": "Extract Content ID",
      "type": "script",
      "outputFormat": "text",
      "script": "module.exports = async function() {\n  // Extract content ID from URL\n  const url = data['content-url-input'] || '';\n  \n  if (!url) {\n    throw new Error('Content URL is required');\n  }\n  \n  // Extract content ID from URL pattern: https://domain.com/content/article-title-content-id\n  // The content ID is the last segment after the last dash\n  const urlParts = url.split('/');\n  const lastPart = urlParts[urlParts.length - 1];\n  \n  // Extract content ID (usually the last segment after the last dash)\n  const segments = lastPart.split('-');\n  const contentId = segments[segments.length - 1];\n  \n  if (!contentId || contentId.length < 10) {\n    throw new Error(`Invalid content ID extracted from URL: ${contentId}`);\n  }\n  \n  console.log(`Extracted content ID: ${contentId}`);\n  return contentId;\n};",
      "nodeIds": ["content-url-input"]
    },
    {
      "id": "parse-languages",
      "nameV2": "Parse Target Languages",
      "type": "python_script",
      "outputFormat": "text",
      "script": "# Python script to parse comma-separated language codes\n# Available global variables:\n# - data: dict containing results from previous nodes\n\nimport sys\n\ndef main():\n    # Get languages string from input\n    languages_str = data.get('target-languages-input', '').strip()\n    \n    if not languages_str:\n        raise Exception('At least one target language is required')\n    \n    # Split by comma and clean up\n    languages = [lang.strip().lower() for lang in languages_str.split(',') if lang.strip()]\n    \n    if len(languages) == 0:\n        raise Exception('No valid languages found')\n    \n    # Use stderr for logging so it doesn't affect the output\n    print(f'Translating to {len(languages)} languages: {\", \".join(languages)}', file=sys.stderr)\n    \n    # Return newline-separated for loop processing\n    result = '\\n'.join(languages)\n    return result\n\n# Execute the main function and print the result\nif __name__ == \"__main__\":\n    output = main()\n    print(output)\n",
      "nodeIds": ["target-languages-input"]
    },
    {
      "id": "download-original-content-once",
      "nameV2": "Download Original Content (Once)",
      "type": "script",
      "outputFormat": "text",
      "script": "module.exports = async function() {\n  const contentUrl = data['content-url-input'] || '';\n  const contentId = data['extract-content-id'] || '';\n  \n  if (!contentUrl) {\n    throw new Error('Content URL is required');\n  }\n  \n  if (!contentId) {\n    throw new Error('Content ID is required');\n  }\n  \n  // Add https:// prefix if not present\n  let fullUrl = contentUrl;\n  if (!fullUrl.startsWith('http://') && !fullUrl.startsWith('https://')) {\n    fullUrl = `https://${fullUrl}`;\n  }\n  \n  console.log(`Downloading original HTML from: ${fullUrl}`);\n  \n  // Fetch HTML content directly from the provided URL\n  const response = await api.fetch(fullUrl);\n  const htmlContent = await response.text();\n  \n  if (!htmlContent || htmlContent.length === 0) {\n    throw new Error('Downloaded content is empty');\n  }\n  \n  console.log(`Downloaded original content: ${htmlContent.length} characters`);\n  \n  // Return JSON with content ID and HTML\n  return JSON.stringify({\n    contentId: contentId,\n    originalHtml: htmlContent,\n    htmlLength: htmlContent.length\n  });\n};",
      "nodeIds": ["content-url-input", "extract-content-id"]
    },
    {
      "id": "translate-all-languages-loop",
      "nameV2": "Translate to All Languages",
      "type": "loop",
      "outputFormat": "text",
      "subNodes": [
        {
          "id": "check-existing-translation",
          "nameV2": "Check Existing Translation",
          "type": "script",
          "outputFormat": "text",
          "script": "module.exports = async function() {\n  const contentId = JSON.parse(data['download-original-content-once']).contentId;\n  const targetLanguage = data['translate-all-languages-loop-loop'] || '';\n  \n  if (!contentId) {\n    throw new Error('Content ID is required');\n  }\n  \n  if (!targetLanguage) {\n    throw new Error('Target language is required');\n  }\n  \n  console.log(`[${targetLanguage}] Checking existing translations for content ID: ${contentId}`);\n  \n  // Check if translation already exists\n  const versionsResponse = await api.frevanaApi.request(\n    'GET',\n    `/s3/content/${contentId}/language-versions`\n  );\n  \n  if (versionsResponse.ok && versionsResponse.data && versionsResponse.data.versions) {\n    const existingTranslation = versionsResponse.data.versions.find(\n      (v) => v.language_code === targetLanguage\n    );\n    \n    if (existingTranslation) {\n      console.log(`[${targetLanguage}] Translation already exists: ${existingTranslation.content_id}`);\n      \n      // Ensure URL has protocol prefix\n      let existingUrl = existingTranslation.url || '';\n      if (existingUrl && !existingUrl.startsWith('http://') && !existingUrl.startsWith('https://')) {\n        existingUrl = `https://${existingUrl}`;\n      }\n      \n      return JSON.stringify({\n        exists: true,\n        contentId: existingTranslation.content_id,\n        originalContentId: contentId,\n        url: existingUrl,\n        targetLanguage: targetLanguage,\n        contentGroupId: versionsResponse.data.content_group_id\n      });\n    }\n  }\n  \n  console.log(`[${targetLanguage}] No existing translation found, proceeding with new translation`);\n  return JSON.stringify({\n    exists: false,\n    contentId: contentId,\n    originalContentId: contentId,\n    targetLanguage: targetLanguage\n  });\n};",
          "nodeIds": ["download-original-content-once", "translate-all-languages-loop-loop"]
        },
        {
          "id": "prepare-translation",
          "nameV2": "Prepare Translation",
          "type": "script",
          "outputFormat": "text",
          "script": "module.exports = async function() {\n  const checkResult = JSON.parse(data['check-existing-translation'] || '{}');\n  const targetLanguage = checkResult.targetLanguage || '';\n  \n  // If translation already exists, skip preparation\n  if (checkResult.exists) {\n    console.log(`[${targetLanguage}] Translation already exists, skipping preparation`);\n    return JSON.stringify({\n      skipTranslation: true,\n      existingContentId: checkResult.contentId,\n      existingUrl: checkResult.url,\n      targetLanguage: targetLanguage,\n      contentGroupId: checkResult.contentGroupId\n    });\n  }\n  \n  const contentId = checkResult.contentId || '';\n  \n  console.log(`[${targetLanguage}] Preparing new translation for content ID: ${contentId}`);\n  \n  // Call prepare-translate API\n  const response = await api.frevanaApi.request(\n    'POST',\n    `/s3/content/${contentId}/prepare-translate`,\n    {\n      target_language: targetLanguage\n    }\n  );\n  \n  if (!response.ok) {\n    throw new Error(`[${targetLanguage}] Failed to prepare translation: ${JSON.stringify(response.data)}`);\n  }\n  \n  const result = response.data;\n  console.log(`[${targetLanguage}] Translation prepared successfully. New content ID: ${result.new_content_id}`);\n  \n  // Return JSON string with all necessary data\n  return JSON.stringify({\n    skipTranslation: false,\n    contentId: contentId,\n    newContentId: result.new_content_id,\n    contentGroupId: result.content_group_id,\n    downloadUrl: result.download_url,\n    uploadUrl: result.upload_url,\n    targetLanguage: targetLanguage,\n    originalLanguage: result.original_language,\n    expiresAt: result.expires_at\n  });\n};",
          "nodeIds": ["check-existing-translation"]
        },
        {
          "id": "get-content-for-translation",
          "nameV2": "Get Content for Translation",
          "type": "script",
          "outputFormat": "text",
          "script": "module.exports = async function() {\n  const prepareResult = JSON.parse(data['prepare-translation'] || '{}');\n  const targetLanguage = prepareResult.targetLanguage || '';\n  \n  // If translation already exists, skip downloading content (major performance optimization)\n  if (prepareResult.skipTranslation && prepareResult.existingUrl) {\n    console.log(`[${targetLanguage}] Translation exists, skipping content download for performance`);\n    \n    // Return lightweight marker - no need to download 100+KB HTML\n    return JSON.stringify({\n      ...prepareResult,\n      isExisting: true,\n      skipAI: true,\n      skipUpload: true\n    });\n  }\n  \n  // Otherwise, get original content for new translation\n  const originalData = JSON.parse(data['download-original-content-once'] || '{}');\n  const originalHtml = originalData.originalHtml;\n  \n  if (!originalHtml) {\n    throw new Error(`[${targetLanguage}] Original HTML content not found`);\n  }\n  \n  console.log(`[${targetLanguage}] Using original content (${originalHtml.length} characters) for translation`);\n  \n  // Return JSON with original HTML content and metadata\n  return JSON.stringify({\n    ...prepareResult,\n    originalHtml: originalHtml,\n    isExisting: false,\n    skipAI: false,\n    skipUpload: false\n  });\n};",
          "nodeIds": ["prepare-translation", "download-original-content-once"]
        },
        {
          "id": "translate-content-smart",
          "nameV2": "Smart Translation",
          "type": "ai_prompt",
          "outputFormat": "text",
          "model": "gpt-4o",
          "prompt": "You are a professional HTML translator. Analyze the following JSON data and respond accordingly:\n\nJSON Data:\n@[Substep-3 Get Content for Translation](get-content-for-translation)\n\nTarget Language: @[Current item in loop](translate-all-languages-loop-loop)\n\nINSTRUCTIONS:\n1. Parse the JSON above\n2. Check if the field 'skipAI' is true:\n   - If YES: Return exactly this text: SKIP_TRANSLATION_EXISTS\n   - If NO: Extract 'originalHtml' field and translate all text content to the target language\n\nTRANSLATION RULES (only if skipAI is false):\n- Preserve ALL HTML tags, attributes, and structure EXACTLY\n- Translate ONLY visible text content within tags\n- Do NOT translate: URLs, class names, IDs, or any HTML attributes\n- Maintain formatting and structure\n- Translate <title> tag content\n\nReturn ONLY the translated HTML content OR the text 'SKIP_TRANSLATION_EXISTS' (no JSON wrapper, no explanations, no markdown code blocks).",
          "nodeIds": ["get-content-for-translation", "translate-all-languages-loop-loop"]
        },
        {
          "id": "upload-translated-content",
          "nameV2": "Upload Translated Content",
          "type": "script",
          "outputFormat": "text",
          "script": "module.exports = async function() {\n  const contentResult = JSON.parse(data['get-content-for-translation'] || '{}');\n  const translatedHtml = data['translate-content-smart'] || '';\n  const targetLanguage = contentResult.targetLanguage || '';\n  \n  // If translation exists (AI returned skip marker), skip upload entirely\n  if (contentResult.skipUpload || translatedHtml.trim() === 'SKIP_TRANSLATION_EXISTS') {\n    console.log(`[${targetLanguage}] Translation exists, skipping upload (fast path)`);\n    return JSON.stringify({\n      ...contentResult,\n      uploadStatus: 'skipped',\n      skipUpload: true\n    });\n  }\n  \n  const uploadUrl = contentResult.uploadUrl;\n  \n  if (!uploadUrl) {\n    throw new Error(`[${targetLanguage}] Upload URL not found`);\n  }\n  \n  if (!translatedHtml) {\n    throw new Error(`[${targetLanguage}] Translated HTML content is empty`);\n  }\n  \n  console.log(`[${targetLanguage}] Uploading translated content to S3 (${translatedHtml.length} characters)...`);\n  \n  // Upload translated HTML to S3 using presigned URL\n  const uploadResponse = await api.fetch(uploadUrl, {\n    method: 'PUT',\n    headers: {\n      'Content-Type': 'text/html'\n    },\n    body: translatedHtml\n  });\n  \n  if (uploadResponse.status !== 200 && uploadResponse.status !== 204) {\n    throw new Error(`[${targetLanguage}] Failed to upload translated content: HTTP ${uploadResponse.status}`);\n  }\n  \n  console.log(`[${targetLanguage}] Translated content uploaded successfully`);\n  \n  // Return JSON with upload confirmation\n  return JSON.stringify({\n    ...contentResult,\n    translatedHtml: translatedHtml,\n    uploadStatus: 'success',\n    skipUpload: false\n  });\n};",
          "nodeIds": ["get-content-for-translation", "translate-content-smart"]
        },
        {
          "id": "confirm-translation",
          "nameV2": "Confirm Translation",
          "type": "script",
          "outputFormat": "text",
          "script": "module.exports = async function() {\n  const uploadResult = JSON.parse(data['upload-translated-content'] || '{}');\n  const targetLanguage = uploadResult.targetLanguage || '';\n  \n  // If using existing translation, skip confirmation and return result summary (fast path)\n  if (uploadResult.skipUpload) {\n    console.log(`[${targetLanguage}] Translation exists, skipping confirmation (fast path)`);\n    \n    // Ensure URL has protocol prefix\n    let existingUrl = uploadResult.existingUrl || '';\n    if (existingUrl && !existingUrl.startsWith('http://') && !existingUrl.startsWith('https://')) {\n      existingUrl = `https://${existingUrl}`;\n    }\n    \n    return JSON.stringify({\n      language: targetLanguage,\n      status: 'existing',\n      contentId: uploadResult.existingContentId,\n      url: existingUrl,\n      htmlLength: 0  // We didn't download HTML for performance\n    });\n  }\n  \n  // For new translations, validate we have translated HTML\n  const translatedHtml = uploadResult.translatedHtml || '';\n  if (!translatedHtml) {\n    throw new Error(`[${targetLanguage}] Translated HTML content is empty`);\n  }\n  \n  const newContentId = uploadResult.newContentId;\n  \n  if (!newContentId) {\n    throw new Error(`[${targetLanguage}] New content ID not found`);\n  }\n  \n  console.log(`[${targetLanguage}] Confirming translation for new content ID: ${newContentId}`);\n  \n  // Extract translated title from HTML\n  let title = 'Translated Content';\n  try {\n    const titleMatch = translatedHtml.match(/<title[^>]*>([^<]+)<\\/title>/i);\n    if (titleMatch && titleMatch[1]) {\n      title = titleMatch[1].trim();\n    }\n  } catch (e) {\n    console.log(`[${targetLanguage}] Could not extract title from HTML`);\n  }\n  \n  // Call confirm-translate API\n  const response = await api.frevanaApi.request(\n    'POST',\n    '/s3/content/confirm-translate',\n    {\n      new_content_id: newContentId,\n      title: title\n    }\n  );\n  \n  if (!response.ok) {\n    throw new Error(`[${targetLanguage}] Failed to confirm translation: ${JSON.stringify(response.data)}`);\n  }\n  \n  const result = response.data;\n  \n  // Ensure URL has protocol prefix\n  let contentUrl = result.url || '';\n  if (contentUrl && !contentUrl.startsWith('http://') && !contentUrl.startsWith('https://')) {\n    contentUrl = `https://${contentUrl}`;\n  }\n  \n  console.log(`[${targetLanguage}] Translation confirmed successfully. Content URL: ${contentUrl}`);\n  \n  // Return translation summary as JSON\n  return JSON.stringify({\n    language: targetLanguage,\n    status: 'new',\n    contentId: newContentId,\n    title: title,\n    url: contentUrl,\n    htmlLength: translatedHtml.length\n  });\n};",
          "nodeIds": ["upload-translated-content"]
        }
      ],
      "prompt": "@[Step-2 Parse Target Languages](parse-languages)"
    },
    {
      "id": "aggregate-results",
      "nameV2": "Aggregate Translation Results",
      "type": "script",
      "outputFormat": "text",
      "script": "module.exports = async function() {\n  const loopResults = data['translate-all-languages-loop'] || '';\n  \n  if (!loopResults) {\n    return JSON.stringify({\n      success: false,\n      message: 'No translation results found'\n    }, null, 2);\n  }\n  \n  let results = [];\n  \n  try {\n    // Check if loopResults is a JSON array string\n    if (loopResults.trim().startsWith('[')) {\n      // Parse as JSON array - each element is a JSON string that needs to be parsed again\n      const jsonArray = JSON.parse(loopResults);\n      console.log(`Loop returned JSON array with ${jsonArray.length} items`);\n      \n      results = jsonArray.map((item, index) => {\n        try {\n          // Each item in the array is a JSON string, parse it\n          const parsed = typeof item === 'string' ? JSON.parse(item) : item;\n          console.log(`[${index}] Parsed translation for language: ${parsed.language || 'unknown'}`);\n          return parsed;\n        } catch (e) {\n          console.log(`Failed to parse array item ${index}: ${e.message}`);\n          return { error: 'Failed to parse result', raw: String(item).substring(0, 100) };\n        }\n      });\n    } else {\n      // Fallback: Parse as newline-separated JSON strings\n      const lines = loopResults.split('\\n').filter(line => line.trim());\n      console.log(`Loop returned newline-separated with ${lines.length} lines`);\n      \n      results = lines.map((line, index) => {\n        try {\n          return JSON.parse(line);\n        } catch (e) {\n          console.log(`Failed to parse line ${index}: ${e.message}`);\n          return { error: 'Failed to parse result', raw: line.substring(0, 100) };\n        }\n      });\n    }\n  } catch (e) {\n    console.error(`Error parsing loop results: ${e.message}`);\n    return JSON.stringify({\n      success: false,\n      message: `Failed to parse translation results: ${e.message}`\n    }, null, 2);\n  }\n  \n  // Count statistics\n  const newTranslations = results.filter(r => r.status === 'new').length;\n  const existingTranslations = results.filter(r => r.status === 'existing').length;\n  const errors = results.filter(r => r.error).length;\n  \n  // Build summary\n  const summary = {\n    success: errors === 0,\n    totalLanguages: results.length,\n    statistics: {\n      newTranslations: newTranslations,\n      existingTranslations: existingTranslations,\n      errors: errors\n    },\n    translations: results.map(result => {\n      if (result.error) {\n        return {\n          language: 'unknown',\n          status: 'error',\n          error: result.error\n        };\n      }\n      return {\n        language: result.language || 'unknown',\n        status: result.status || 'unknown',\n        contentId: result.contentId || '',\n        url: result.url || '',\n        title: result.title || '',\n        htmlLength: result.htmlLength || 0\n      };\n    })\n  };\n  \n  console.log(`\\n=== Translation Summary ===`);\n  console.log(`Total Languages: ${summary.totalLanguages}`);\n  console.log(`New Translations: ${newTranslations}`);\n  console.log(`Existing Translations: ${existingTranslations}`);\n  console.log(`Errors: ${errors}`);\n  console.log(`=========================\\n`);\n  \n  return JSON.stringify(summary, null, 2);\n};",
      "nodeIds": ["translate-all-languages-loop"]
    },
    {
      "id": "format-output",
      "nameV2": "Format Output Report",
      "type": "ai_prompt",
      "outputFormat": "text",
      "prompt": "Format the translation results into a beautiful markdown report.\n\nTranslation Summary Data:\n@[Step-5 Aggregate Translation Results](aggregate-results)\n\nCreate a markdown report with:\n1. Overall summary (total languages, success rate)\n2. Detailed results for each language in a table with these columns ONLY:\n   - Language Code\n   - Status (New/Existing/Error)\n   - URL (clickable link if available)\n   \n   DO NOT include Content ID column in the table.\n   \n3. Statistics breakdown\n4. Any errors or warnings\n\nUse proper markdown formatting with headers, bullet points, and tables where appropriate.\nMake it easy to read and professional.",
      "nodeIds": ["aggregate-results"]
    }
  ],
  "results": [
    {
      "type": "plain_text",
      "fields": [],
      "items": { "content": "format-output" }
    }
  ],
  "inputValues": {
    "content-url-input": [],
    "target-languages-input": []
  },
  "version": "1.0",
  "metadata": {
    "author": "Frevana-AI",
    "createdAt": "2025-12-15T10:00:00.000Z",
    "description": "Multi-language content translation workflow with loop support"
  },
  "frequency": "-1",
  "mcpConfigs": {},
  "workflowConnects": []
}
